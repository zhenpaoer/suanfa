
⾯试题也可以⽤回溯算法来解决，如⼋皇后问题，排列组合问题，0-1背包问题，数独问题等
什么是回溯算法
回溯算法本质其实就是枚举，在给定的枚举集合中，不断从其中尝试搜索找到问题的解，如果在搜索过
程中发现不满⾜求解条件 ，则「回溯」返回，尝试其它路径继续搜索解决，这种⾛不通就回退再尝试其
它路径的⽅法就是回溯法，许多复杂的，规模较⼤的问题都可以使⽤回溯法，所以回溯法有「通⽤解题
⽅法」的美称。
回溯算法解题通⽤套路
function backtrace(已选解集合,每个阶段可选解) {
     if (已选解集合满⾜条件) {
         结果集.add(已选解集合);
         return;
     }
     // 遍历每个阶段的可选解集合
     for (可选解 in 每个阶段的可选解) {
         // 选择此阶段其中⼀个解,将其加⼊到已选解集合中
         已选解集合.add(可选解)
         // 进⼊下⼀个阶段
         backtrace(已选解集合,下个阶段可选的空间解)
         // 「回溯」换个解再遍历
         已选解集合.remove(可选解)
     }
 }
 综上，我们可以得出回溯算法的基本套路如下：
 1. 将问题分成多个阶段，每个阶段都有多个不同的解，这样就将问题转化成了树形问题，这⼀步是问
 题的关键！如果能将问题转成树形问题，其实就成功了⼀半，需要注意的是树形问题要明确终⽌条
 件，这样可以在 DFS 的过程中及时终⽌遍历，达到剪枝的效果
 2. 套⽤上述回溯算法的解题模板，进⾏深度优先遍历，直到找到问题的解。

总结
 使⽤回溯算法解题的关键是把问题分成多阶段，每个阶段都有相应的解，于是就把问题转成了树形问
 题，转成树形问题后，剩下的只需要套⽤上⽂总结的解题模板即可，尤其需要注意的是，当遍历当前阶
 段解的时候，可以根据之前阶段的解作「剪枝」操作，这样使问题的搜索规模变⼩，有效降低了问题的
 复杂度。


排列组合
    排列数：元素的排列方式会影响排列的数量。不同的排列顺序（如ABC、ACB、BCA）会被视为不同的排列。顺序相关
    组合数：元素的组合方式不影响组合的数量。所有组合（如ABC、ACB、BCA）会被视为相同的组合。顺序无关

    1. 如果求组合数就是外层for循环遍历物品，内层for遍历背包。（背包问题求解）
    2. 如果求排列数就是外层for遍历背包，内层for循环遍历物品。（爬楼梯）

背包问题--是指求与顺序无关的组合数
    背包问题 (Knapsack problem) 是一种组合优化的 NP (NP-Complete) 完全问题。
    问题可以描述为：给定一组物品，每种物品都有自己的重量和价格，在限定的总重量内，我们如何选择，才能使得物品的总价格最高。
    问题的名称来源于如何选择最合适的物品放置于给定背包中。

    一般问题： 我们有n件物品和一个容量 (capacity) 为 C 的背包，记第i件物品的重量 (weight)W[i] 为价值 (value) 为 V[i]，
    求将哪些物品装入背包可使价值总和最大。

    0-1背包： 如果限定每件物品最多只能选取 1 次（即 0或1 次），则问题称为 0-1背包问题。
    完全背包： 如果每件物品最多可以选取无限次，则问题称为 完全背包问题。

  0-1背包
     状态定义：dp[i][j]  表示前 i  件物品放入一个容量为 j 的背包可以获得的最大价值（每件物品最多放一次）
     不选择第 i 件物品，则问题转化为了前 i−1 件物品放入容量为 j 的背包中所获得的价值
     选择第 i 件物品，则问题转化为了前 i−1 件物品放入容量为 j−W[i]的背包中所获得的价值
     状态转移方程：dp[i][j] = Math.max(dp[i-1][j],dp[i-1][j-Wi]+Vi)

     (货币选择题 coins1题)
     状态定义：dp[i][j]  表示前 i 个货币，可以达到值为 j 的组合数（每件货币最多选一次）
     不选择第 i 件货币，则问题转化为了前 i+1 货币可以达到值为 j 的组合数
     选择第 i 件物品，则问题转化为了前 i+1 件货币可以达到值为 j−arr[i]的组合数
     状态转移方程：dp[i][j] = dp[i+1][j] + dp[i+1][j-arr[i]]


  完全背包


  货币类题目：
    给出硬币的数组，给出目标金额，限制条件：
                |        面值相同                 |         面值不同
    -------------------------------------------------------------------------------------
    不限制张数    | 差别只在dp每格的枚举数量的个数     |
                |                               |            coins2题、MinCoins题
    --------------------------------------------------------------------------------------
    限制张数     |  差别只在dp每格的枚举数量的个数    |         就每个位置选拿or不拿
                |                              |            coins1（0-1背包）、coins3题


    总结：
        在只用一个一维数组的情况下，要注意转移来源
        1. 不能被覆盖 2. 必须已经计算出来。
        正序遍历会导致 0-1 背包状态被覆盖，而完全背包则是正确的（转移来源被计算出来，且不存在被覆盖的问题）；
        逆序遍历对于 0-1 背包是正确的（转移来源是上一行的，早就被计算出来了且没有被覆盖），而完全背包则不行（转移来源没有被计算出来）。

    求最值==> Math.max/min
    至多至少
    方法数 ==> 加法
